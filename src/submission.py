"""
The purpose of this file is to generate the submission files for the Kaggle competition.

The submission files are generated by the function `generate_submission` which takes as input the predictions of the model
and the name of the file to be generated.


Authors : Theo Schifferli, Jérémy Barghorn, Jérémy Chaverot
Date : 20.11.2024
"""

import pandas as pd
import logging
import matplotlib.pyplot as plt
import shap
import os
import re

from fpdf import FPDF
from sklearn.cluster import KMeans
from src.plots import *
from IPython.display import Markdown


# Sst up logging
logging.basicConfig(
    level=logging.INFO,  
    format="%(asctime)s - %(levelname)s - %(message)s",  #
    handlers=[logging.StreamHandler()]  # Output logs to the console/cell
)
log = logging.getLogger(__name__)  # create a logger

def generate_submission(model, x_test, scaler, selector = None, filename_csv = "predictions.csv", image_directory = "./shap_plots/", explanation_directory = "explanations/", filename_pdf = "explanations.pdf"):
    """
    Generate the submission file and SHAP explanations for a Kaggle competition.

    This function performs the following tasks:
        1. Validates input filenames and paths.
        2. Ensures the required SHAP plots directory exists or creates it.
        3. Creates a CSV file with predictions for submission.
        4. Generates a PDF file containing SHAP explanation plots.

    Args:
        model (object): The trained model used to make predictions on the test set.
        x_test (pd.DataFrame): The test set data. Index values should uniquely identify samples.  Should be scaled.
        scaler (object): The scaler used to preprocess the data. The data should not be scaled.
        selector (object, optional): The feature selector used to select features. Defaults to None.
        filename_csv (str, optional): The name of the CSV file to save predictions. Defaults to "predictions.csv".
        image_directory (str, optional): Directory where SHAP plots are saved. Defaults to "shap_plots".
        filename_pdf (str, optional): The name of the PDF file to save SHAP explanations. Defaults to "explanations.pdf".
        use_scaler (bool, optional): Whether to use the scaler to transform the test data. Defaults to True.

    Raises:
        ValueError: If `filename_csv` does not have a ".csv" extension.
        ValueError: If `filename_pdf` does not have a ".pdf" extension.
        AssertionError: If the number of feature names does not match the number of features in the test set.
        AssertionError: If `x_test` is not a DataFrame.

    Returns:
        None. Generates files in the specified locations.
    """
    if filename_csv[-4:] != ".csv":
        raise ValueError("The filename should end with .csv")
    
    if filename_pdf[-4:] != ".pdf":
        raise ValueError("The filename should end with .pdf")
    
    if not os.path.exists(image_directory):
        os.makedirs(image_directory)

    assert(type(x_test) == pd.DataFrame), "x_test should be a DataFrame"

    x_test_scaled = scaler.transform(x_test)
    if selector:
        x_test_scaled = selector.transform(x_test)
    y_pred = model.predict(x_test_scaled)
    
    assert len(x_test) == len(y_pred), "The number of predictions should match the number of samples in the test set"

    log.info(f"Generating submission file {filename_csv}")
    predictions = pd.DataFrame({"sampleId": x_test.index, "AAC": y_pred})
    predictions["sampleId"] = predictions["sampleId"].apply(lambda x: x.replace("CL", "TS"))
    predictions.to_csv(filename_csv, index=False)
    log.info(f"Submission file {filename_csv} has been generated successfully")

    # Generate the PDF
    generate_pdf_with_explanations(image_dir=image_directory, explanation_dir=explanation_directory, output_pdf=filename_pdf)



def generate_pdf_with_explanations(image_dir="shap_plots_new/", explanation_dir="short_explanations/", output_pdf="./pdf/explanations.pdf"):
    """
    Generate a PDF file with images and corresponding explanations.

    Parameters:
    - image_dir: Directory containing SHAP decision plot images.
    - explanation_dir: Directory containing explanation text files.
    - output_pdf: Name of the output PDF file.
    """
    import os
    import re
    from fpdf import FPDF

    # Initialize the PDF object
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)

    # Ensure output directory exists
    output_dir = os.path.dirname(output_pdf)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Function to extract type ('Top' or 'Bottom') and numeric value from filenames
    def extract_type_and_number(filename):
        """
        Extract the type ('Top' or 'Bottom') and numeric value from filenames with the pattern <type>_<number>_<id>.<extension>.
        Returns a tuple ('type', number) for sorting purposes.
        """
        match = re.match(r"(Top|Bottom)_(\d+)_", filename)
        if match:
            tier = match.group(1)  # 'Top' or 'Bottom'
            number = int(match.group(2))  # Extract the numeric part
            return tier, number
        return "Z", float('inf')  # Default for unmatched files, placing them at the end

    # list and sort image files
    images = [f for f in os.listdir(image_dir) if f.endswith(".png")]
    sorted_images = sorted(images, key=lambda x: (extract_type_and_number(x)[0], extract_type_and_number(x)[1]))

    # list and sort explanation files
    explanations = [f for f in os.listdir(explanation_dir) if f.endswith(".txt")]
    sorted_explanations = sorted(explanations, key=lambda x: (extract_type_and_number(x)[0], extract_type_and_number(x)[1]))


    # add title page
    pdf.add_page()
    pdf.set_font("Helvetica", size=10, style="B")
    pdf.cell(0, 2, "xAI in Cancer Medicine: Automated Report", ln=True, align='L')
  
    pdf.set_font("Helvetica", size=10)
    pdf.cell(0, 2, "Jérémy Barghorn, Jérémy Chaverot, Théo Schifferli", ln=True, align='R')
    pdf.ln(2)
    pdf.set_font("Helvetica", size=10, style="I")
    pdf.cell(0, 2, "Department of Computer Science, EPFL", ln=True, align='L')

    pdf.ln(6)
    # Process images and explanations
    for image, explanation in zip(sorted_images, sorted_explanations):
        sample_name = image.split(".")[0]
        parts = sample_name.split("_")
        tier = parts[0].capitalize()  # Either "Top" or "Bottom"
        rank = int(parts[1]) + 1
        sample_id = parts[2]

        # Title for the image and explanation
        title = f"{tier} {rank} Sample: {sample_id}"

        # Read the explanation text
        with open(os.path.join(explanation_dir, explanation), "r") as file:
            explanation_text = file.read()
        # Add the title
        pdf.set_font("Helvetica", size=9, style="B")
        pdf.set_x(10)  # Reset cursor to the left margin
        pdf.cell(0, 10, title, align='C', ln=True)  # Center the title and move to the next line

        # Add the image
        image_y = pdf.get_y()
        image_height = 20
        image_width = 80
        # Check if the image fits, otherwise add a new page
        if image_y + image_height > pdf.h - 15:  # 15 is the bottom margin
            pdf.add_page()  # Add a new page
            image_y = 10  # Reset the y-coordinate to the top margin

        # Add the image
        pdf.image(os.path.join(image_dir, image), x=(pdf.w-image_width)/2, y=image_y, w=image_width)

        # Add the explanation text to the right of the image
        text_x= 5
        text_y = image_y + 40
        pdf.set_xy(text_x, text_y)
        pdf.set_font("Helvetica", size=8)
        pdf.multi_cell(pdf.w - 10, 4, explanation_text, markdown=True)

    # Save the PDF
    pdf.output(output_pdf)
    print(f"PDF generated: {output_pdf}")
